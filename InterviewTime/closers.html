<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>JavaScript Closures - Interview Notes</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            line-height: 1.6;
        }
        code {
            background: #f4f4f4;
            padding: 5px;
            border-radius: 5px;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border-radius: 5px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>JavaScript Closures - Interview Notes</h1>
    
    <h2>Common Interview Questions and Answers</h2>
    <ol>
        <li><strong>What is a closure in JavaScript?</strong><br>
            A closure is a function that retains access to its parent function's variables even after the parent function has executed.</li>
        
        <li><strong>How do closures work in JavaScript?</strong><br>
            Closures work by preserving the lexical scope of a function, meaning an inner function has access to variables from its outer function even after the outer function has returned.</li>
        
        <li><strong>Why are closures useful?</strong><br>
            Closures help in:
            <ul>
                <li><strong>Data Encapsulation:</strong> Keeping variables private.</li>
                <li><strong>Function Factories:</strong> Creating dynamic functions.</li>
                <li><strong>Maintaining State:</strong> Keeping values between function calls.</li>
                <li><strong>Handling Asynchronous Operations:</strong> Managing event listeners and setTimeout.</li>
            </ul>
            <pre><code>// Data Encapsulation Example
function createCounter() {
    let count = 0;
    return function () {
        count++;
        console.log(count);
    };
}

const counter = createCounter();
counter(); // Output: 1
counter(); // Output: 2
            </code></pre>
            <pre><code>// Function Factory Example
function multiplier(factor) {
    return function (number) {
        return number * factor;
    };
}

const double = multiplier(2);
console.log(double(5)); // Output: 10
            </code></pre>
            <pre><code>// Maintaining State Example
function rememberMe() {
    let message = "Hello!";
    return function () {
        console.log(message);
    };
}

const greet = rememberMe();
greet(); // Output: Hello!
            </code></pre>
            <pre><code>// Handling Asynchronous Operations Example
function delayedMessage(msg, delay) {
    setTimeout(function () {
        console.log(msg);
    }, delay);
}

delayedMessage("Hello after 2 seconds", 2000); // Output: Hello after 2 seconds
            </code></pre>
        </li>
        
        <li><strong>Give an example of a closure in JavaScript.</strong>
            <pre><code>function outerFunction() {
    let outerVariable = "Hello";
    
    function innerFunction() {
        console.log(outerVariable); // Accessing the outer variable
    }
    
    return innerFunction;
}

let myClosure = outerFunction();
myClosure(); // Output: Hello</code></pre>
        </li>
        
        <li><strong>What are some real-world use cases of closures?</strong>
            <ul>
                <li>Creating private variables in JavaScript.</li>
                <li>Using closures in event listeners.</li>
                <li>Maintaining state in setTimeout and setInterval.</li>
                <li>Function currying and function factories.</li>
            </ul>
        </li>
        
        <li><strong>How do closures help in data hiding?</strong><br>
            Closures enable data encapsulation by keeping variables private inside a function and providing controlled access via inner functions.</li>
        
        <li><strong>Can closures lead to memory leaks? If so, how?</strong><br>
            Yes, closures can cause memory leaks if they retain references to large objects or DOM elements that are no longer needed, preventing garbage collection.</li>
        
        <li><strong>What are some alternatives to closures?</strong>
            <ul>
                <li>Using ES6 classes for encapsulation.</li>
                <li>Using modules to manage private variables.</li>
                <li>Using WeakMap to prevent memory leaks while storing private data.</li>
            </ul>
        </li>
    </ol>

    <h2>Key Takeaways</h2>
    <ul>
        <li>Closures allow functions to maintain access to their outer scope.</li>
        <li>They help in data encapsulation and state persistence.</li>
        <li>Widely used in JavaScript for event handling, timers, and functional programming.</li>
    </ul>
</body>
</html>