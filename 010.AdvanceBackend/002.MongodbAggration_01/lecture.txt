Aggregation -Aggregate

Aggregate -> what do u understand by it ? => is to collect something 


Find all the students in a school, count the no of boys and girls, then you want to find average marks of each group in xyz evaluation , again do some operation on that

===>>How will you do it  with normal query
              const  boysgroup = db.collection.find({gender: "male"})
              const  girlsgroup = db.collection.find({gender: "Female"})
                 

           const  boyscount =boygroup.length; 
           const  girlscount =girlgroup.length;
           const totalStudents = boysgroup.length+girlsgroup.length     


and so on.....for finding avg marks ......for each group ........ its getting complex on server side right mean have to write codes for each step .....

Thats when Aggregation comes in ....To write complex query in a BETTER WAY 


Aggregation - helps us with writing complex queries and 1st point bellow. 
  
  1. Filtering happening on the DB level  - Basically reducing the server load 
                 Vs
  2. Filtering happening on the server    


Advantages of Aggregation 
                   -reducing the server load 
                   -dont want to get unnessessary data from databse 
                   -less codes on server side 
                   -all those things

 


 Pipeline -  its connection of stages  like... =[  stage1 (each single pipe)..stage2...stage3....stage n ]=
              
              eg..stage1 passing fresh water to stage2  (here we have a process which add salt)....and passes to stage3 (adding suger ) passing the solution to last stage -end of the pipeline 
    
    *The point is that " The Output of each Stage is  the input for the  next stage "



AggregationPipeline ->      [stage1(query1)-> stage2(query2) ->Stage3(query3)->stage n(query(n)) ]


                             eg. lets take AggregationPipeline1...

                             ====[1000ppldata --> stage1(anycriteria like height is less than x)  -->> stage2(just printing ?is there 1000ppl data -nope) --->lets 200ppl---> stage3() ....and so on......]=====
                               

                            OneMore_Aggregation_Pipeline...
                            
                            ====[1000ppldata --> stage1(anycriteria like height is less than 5.2feet) -->200ppl -->> stage2(criteria weight is 100+kg) --->noone--> 0ppl---> stage3(printtop4ppl)---nope! 0 ]=====
                    

         *The point is that " The Output of each Stage is  the input for the  next stage "
          mean the 
                   input of n stage === output of n-1 stage 




//Syntax 
 db.students.aggregate([ { stage1 } , { stage2 } ,{ stage3 } , { stage_n } ]) ->output

   //each stage in bracket format seperated with , inside an arraystructure
   //and within each satge we have something called as  "Aggregation Operators"; 


                    **There are various Aggregation Operators : 
                    $match 
                    $filter 
                    $limit
                    $group 
                    $lookup 
                                 -you may have come across this dollor symbol  while expolored documentation for mongodb  right ! 
                                         like..$sum $average ....


you can search for ---- "Aggregation Operators documentation"

      #dtaset for performing actions on it :-  "https://gist.github.com/kishukumar07/057288cbc95673baca116e7c5ebc974b"


                 --acessed  data ??   created a collection in db "mongoAggregation"
                                                              created a  collection  
                                                              "orders and inserted   the data in it "      
    
  visit from here  for ./mongosh.md ==>> 
